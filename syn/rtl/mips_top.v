
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module mips_top(

	//////////// CLOCK //////////
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// SEG7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// SW //////////
	input 		     [9:0]		SW
);



//=======================================================
//  REG/WIRE declarations
//=======================================================

    wire clock;
	// To instruction Memory
    wire [31:0] pc;
    wire [31:0] instr;
    // To Data Memory
    wire memwrite;
    wire [31:0] memaddr,writedata;
    wire [31:0] readdata,s0;


//=======================================================
//  Structural coding
//=======================================================
instr_mem #(.DEPTH(128),.WIDTH(8)) u_instr_mem(
    .clk(clock),
    .rst_n(!KEY[1]),
    .address(pc),
    .data_out(instr)
);

// data_mem #(.DEPTH(128),.WIDTH(8)) u_data_mem(
//     .clk(CLOCK_50),
// 	 .rst_n(1'b1),
// 	 .address(memaddr),
//     // input for write operation
//     .write_en(memwrite),
//     .data_in(writedata),
//     // output for read operation
//     .data_out(readdata)
// );

data_mem #(.MEM_SIZE(64),.DATA_WIDTH(32)) u_data_mem 
(
    .clk(clock),
    // output for read operation
	.read_addr(memaddr),
	.data_out(readdata),
    // input for write operation
	.write_addr(memaddr),
	.data_in(writedata),
	.write_enable(memwrite)  
	);

mips_core u_mips_core (
    .clk(clock),
    .rst_n(KEY[1]),
    // To instruction Memory
    .pc(pc),
    .instr(instr),
    // To Data Memory
    .memwrite(memwrite),
    .memaddr(memaddr),
	.writedata(writedata),
    .readdata(readdata),
    .s0(s0)
);


debugger u_debugger(
    .i_clk(CLOCK_50),
    .clk(clock),
    // FPGA Inputs
    .KEY(KEY),
    .SW(SW),
    // To instruction Memory
    .pc(pc),
    .instr(instr),
    // To Data Memory
    .memwrite(memwrite),
    .memaddr(memaddr),
    .writedata(writedata),
    .readdata(readdata),
    .regfile(s0), 
    // FPGA Output
    .HEX0(HEX0),
    .HEX1(HEX1),
    .HEX2(HEX2),
    .HEX3(HEX3),
    .HEX4(HEX4),
    .HEX5(HEX5),
    .LEDR(LEDR)
);

endmodule 

module debugger (
    input i_clk,
    output clk,
    // FPGA Inputs
	input [3:0] KEY,
	input [9:0] SW,
    // To instruction Memory
    input [31:0] pc,
    input [31:0] instr,
    // To Data Memory
    input memwrite,
    input [31:0] memaddr,writedata,
    input [31:0] readdata, 
    input [31:0] regfile,
    // FPGA Output
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,
    output		     [9:0]		LEDR
);
    // Clock Selection
        // Manual Clock vs 50MHz Clock
        assign clk   = (SW[9])? i_clk:KEY[0];
    // Data Selection
        reg [31:0] data;
        always @(*) begin
            case (SW[3:0])
                4'd0: data = pc;
                4'd1: data = {16'b0,instr[15:0]};
                4'd2: data = {16'b0,instr[31:16]};
                4'd3: data = memaddr;
                4'd4: data = regfile;
                4'd5: data = writedata; 
                4'd6: data = readdata;
                default: data = 'hffff_ffff; 
            endcase
        end
    // Data showing
        bin2hex nipple_0 (
            .i_bin(data[3:0]),
            .o_hex(HEX0) 
        );
        bin2hex nipple_1 (
            .i_bin(data[7:4]),
            .o_hex(HEX1) 
        );
        bin2hex nipple_2 (
            .i_bin(data[11:8]),
            .o_hex(HEX2) 
        );
        bin2hex nipple_3 (
            .i_bin(data[15:12]),
            .o_hex(HEX3) 
        );
        bin2hex nipple_4 (
            .i_bin(4'hf),
            .o_hex(HEX4) 
        );
    // address Showing    
        bin2hex nipple_5 (
            .i_bin(SW[3:0]),
            .o_hex(HEX5) 
        );
    
        assign LEDR[9]    = SW[9];   // For indiacation on Clock type
        assign LEDR[8]    = clk;     // For indiacation on Clock type
        assign LEDR[7]    = KEY[1];  // For indiacation on Clock type
        assign LEDR[3:0]  = SW[3:0]; // For indiacation on Clock type       
endmodule
